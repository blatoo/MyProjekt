package netflixSampleAnalyzer;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Locale;
import java.util.StringTokenizer;

import edges.EdgeWithIDAndWeight;

public class Analyzer {

	public static int numberOfFilms = 17770;
	public static int numberOfSamples = 5000;
	private static Locale loc = Locale.GERMAN;
	private static NumberFormat nf = NumberFormat.getNumberInstance(loc);
	private static DecimalFormat myFormatter = (DecimalFormat)nf;
	
	
	
	public static void main(String[] args){
		myFormatter.applyPattern("0.00000E0");
		new Analyzer().doAnalysis();
	}
	
	
	/**
	 * Note that this class will only work if maxDegree and maxCoocc are below 32767 and can thus be represented as a short
	 * 
	 * This function reads in the data sets generated by ExperimentalTesterForNetflixData. 
	 */
	public void doAnalysis(){
		int numberOfBaskets = 10000;
		int numberOfBestRankings = 20;
		String parDirFile = "/home/nina/Data/Netflix/NewCoocc";
		String[] files = {"01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36"};

		for(String file: files){
			//degrees[A]/numberOfBaskets = pA
			short[] degrees = readInDegrees(parDirFile+File.separator+"degree_"+file+".txt");
			String[] titles = readInMovieTitles("/home/nina/Data/Netflix/movie_titles.txt");
						
			String originalFileURL = parDirFile+File.separator+"original_"+file+".txt";
			String simFileURL = parDirFile+File.separator+"sim_"+file+".txt";
			
			String line;
			StringTokenizer st;
			int firstFilm, secondFilm, currentCooccs = 0;
			double[] simCooccs = new double[numberOfFilms];
			double value;
			
			
			LinkedList<EdgeWithIDAndWeight<Integer>> best_OldLift_100 = new LinkedList<EdgeWithIDAndWeight<Integer>>();
			LinkedList<EdgeWithIDAndWeight<Integer>> best_newLift_100 = new LinkedList<EdgeWithIDAndWeight<Integer>>();
			LinkedList<EdgeWithIDAndWeight<Integer>> best_oldLeverage_100 = new LinkedList<EdgeWithIDAndWeight<Integer>>();
			LinkedList<EdgeWithIDAndWeight<Integer>> best_newLeverage_100 = new LinkedList<EdgeWithIDAndWeight<Integer>>();
			LinkedList<EdgeWithIDAndWeight<Integer>> best_convictionAB_100 = new LinkedList<EdgeWithIDAndWeight<Integer>>();
			LinkedList<EdgeWithIDAndWeight<Integer>> best_newConvictionAB_100 = new LinkedList<EdgeWithIDAndWeight<Integer>>();
			LinkedList<EdgeWithIDAndWeight<Integer>> best_convictionBA_100 = new LinkedList<EdgeWithIDAndWeight<Integer>>();
			LinkedList<EdgeWithIDAndWeight<Integer>> best_newConvictionBA_100 = new LinkedList<EdgeWithIDAndWeight<Integer>>();
			
			
			try {
				BufferedReader br = new BufferedReader(new FileReader(new File(originalFileURL)));
				BufferedReader brSim = new BufferedReader(new FileReader(new File(simFileURL)));
				line = br.readLine();
				String lineSim = brSim.readLine();
				int counter = 0; 
				int id = 0;
				
				while(line != null ){
					++counter;
					st = new StringTokenizer(line);
					firstFilm = Integer.parseInt(st.nextToken());
					if(firstFilm > currentCooccs){
						lineSim = readInCoocsLine(brSim, firstFilm, lineSim, simCooccs);
						if(simCooccs == null)System.out.println("sim cooccs is null");
						currentCooccs = firstFilm;
					}
					
					secondFilm = Integer.parseInt(st.nextToken());
					value = Double.parseDouble(st.nextToken()); 
					
//					System.out.println(titles[firstFilm]+" (degree = "+degrees[firstFilm]+") has been corented with "+titles[secondFilm]+" (degree = "+degrees[secondFilm]+ ") "+value+" times (sim: "+simCooccs[secondFilm]+")");
					
					double pA = (double)degrees[firstFilm]/numberOfBaskets;
					double pB = (double)degrees[secondFilm]/numberOfBaskets;
					double pAB = value/(double)numberOfBaskets;
					double pAB_sim = simCooccs[secondFilm]/(double)numberOfBaskets;
					//lift(A,B) = p(A,B)/(p(A)*p(B))
					double oldLift = pAB/pA/pB;
					double newLift = pAB_sim > 0 ? pAB/pAB_sim : Double.MAX_VALUE;
					//leverage(A,B) = p(A,B)-(p(A)*p(B))
					double oldLeverage = (pAB-(pA*pB))*numberOfBaskets;
					double newLeverage = (pAB-pAB_sim)*numberOfBaskets;
					//confidence(A -> B) = p(A,B)/p(A)
					double confidenceAB = pAB/pA;	
					double confidenceBA = pAB/pB;
					//conviction(A -> B) = [1-p(A,B)]/[1-confidence(A->B)]
					double convictionAB = confidenceAB < 1.0 ? (1.0-pAB)/(1.0-confidenceAB) : Double.MAX_VALUE;
					double convictionBA = confidenceBA < 1.0 ? (1.0-pAB)/(1.0-confidenceBA) : Double.MAX_VALUE;
					double newConvictionAB = pA-pAB > 0 ? (pA-pAB_sim)/(pA-pAB) : Double.MAX_VALUE;
					double newConvictionBA = pB-pAB > 0 ? (pB-pAB_sim)/(pB-pAB) : Double.MAX_VALUE;
					
//					System.out.println("  lift: "+oldLift+":"+newLift);
//					System.out.println("  leverage: "+oldLeverage+":"+newLeverage);
//					System.out.println("  conviction A->B: "+convictionAB+":"+newConvictionAB);
//					System.out.println("  conviction B->A: "+convictionBA+":"+newConvictionBA);
			
					if(oldLift > 1.0)
						addIntoAscendingList(best_OldLift_100, new EdgeWithIDAndWeight(firstFilm, secondFilm, id, oldLift), numberOfBestRankings);
					if(newLift > 1.0)
						addIntoAscendingList(best_newLift_100, new EdgeWithIDAndWeight(firstFilm, secondFilm, id, newLift), numberOfBestRankings);
					
					
					if(oldLeverage > 0)
						addIntoAscendingList(best_oldLeverage_100, new EdgeWithIDAndWeight(firstFilm, secondFilm, id, oldLeverage), numberOfBestRankings);
					if(newLeverage > 0)
						addIntoAscendingList(best_newLeverage_100, new EdgeWithIDAndWeight(firstFilm, secondFilm, id, newLeverage), numberOfBestRankings);
					
					if(convictionAB > 1.0)
						addIntoAscendingList(best_convictionAB_100, new EdgeWithIDAndWeight(firstFilm, secondFilm, id, convictionAB), numberOfBestRankings);
					if(newConvictionAB > 1.0)
						addIntoAscendingList(best_newConvictionAB_100, new EdgeWithIDAndWeight(firstFilm, secondFilm, id, newConvictionAB), numberOfBestRankings);
					
					if(convictionBA > 1.0)
						addIntoAscendingList(best_convictionBA_100, new EdgeWithIDAndWeight(firstFilm, secondFilm, id, convictionBA), numberOfBestRankings);
					if(newConvictionBA > 1.0)
						addIntoAscendingList(best_newConvictionBA_100, new EdgeWithIDAndWeight(firstFilm, secondFilm, id, newConvictionBA), numberOfBestRankings);
					
					line = br.readLine();
				}
			} catch (NumberFormatException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			try {
				String fileURL = parDirFile+File.separator+"rankings_"+file+".txt";
				BufferedWriter bw = new BufferedWriter(new FileWriter(new File(fileURL)));
				bw.write("#First column: film1 (filmID -1)\n");
				bw.write("#Second column: film1.degree \n");
				bw.write("#Third column: film2 (filmID -1)\n");
				bw.write("#Fourth column: film2.degree (filmID -1)\n");
				bw.write("#Fifth column: old value (filmID -1)\n");
				bw.write("#The same for the new, improved interestingness measure \n");
				bw.write("#Sixth column: film1 (filmID -1)\n");
				bw.write("#Seventh column: film1.degree \n");
				bw.write("#Eighth column: film2 (filmID -1)\n");
				bw.write("#Nineth column: film2.degree (filmID -1)\n");
				bw.write("#Tenth column: new value (filmID -1)\n");
				
				printOutBest(bw, best_OldLift_100, best_newLift_100, "Best lift rankings (old vs. new)", degrees);
				printOutBest(bw, best_oldLeverage_100, best_newLeverage_100, "Best leverage rankings (old vs. new)", degrees);
				printOutBest(bw, best_convictionAB_100, best_newConvictionAB_100, "Best convictionAB rankings (old vs. new)", degrees);
				printOutBest(bw, best_convictionBA_100, best_newConvictionBA_100, "Best convictionBA rankings (old vs. new)", degrees);
				
				bw.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			//end of scanning all files
		}
	}


	private void printOutBest(BufferedWriter bw, LinkedList<EdgeWithIDAndWeight<Integer>> best_OldMeasure,	LinkedList<EdgeWithIDAndWeight<Integer>> best_newMeasure, String description, short[] degrees) {
		try {
			
			
			
			Collections.reverse(best_OldMeasure);
			Collections.reverse(best_newMeasure);
			EdgeWithIDAndWeight<Integer> edge1, edge2;
		
			bw.write("\n");
			bw.write("\n");
			bw.write("\n");
			bw.write("#"+description+"\n");
			
			for(ListIterator<EdgeWithIDAndWeight<Integer>> li = best_OldMeasure.listIterator(), liNew = best_newMeasure.listIterator(); li.hasNext()||liNew.hasNext();){
				
				edge1 = li.hasNext() ? li.next() : null;
				edge2 = liNew.hasNext() ? liNew.next() : null;
//			System.out.println(titles[edge1.node1]+" : "+titles[edge1.node2]+" ("+edge1.value+")  vs. "+titles[edge2.node1]+" : "+titles[edge2.node2]+" ("+edge2.value+")");
				if(edge1 != null)
					bw.write(edge1.node1+"\t"+degrees[edge1.node1]+"\t"+edge1.node2+"\t"+degrees[edge1.node2]+"\t"+nf.format(edge1.value));
				else
					bw.write("\t\t\t\t\t");
				if(edge1 != null && edge2 != null)
					bw.write("\t");
				if(edge2 != null)
				    bw.write(edge2.node1+"\t"+degrees[edge2.node1]+"\t"+edge2.node2+"\t"+degrees[edge2.node2]+"\t"+nf.format(edge2.value)+"\n");
			}
		} catch (IOException e) {
			e.printStackTrace();
			System.exit(-1);
		}

		
	}


	private void addIntoAscendingList(LinkedList<EdgeWithIDAndWeight<Integer>> sortedList, EdgeWithIDAndWeight<Integer> edge, int lengthOfList) {
		if(sortedList.size() == 0){
			sortedList.add(edge);
			return;
		}
		double currentDouble;
		boolean hasBeenAdded = false;
		ListIterator<EdgeWithIDAndWeight<Integer>> it = sortedList.listIterator(); 
		while(it.hasNext()){
			currentDouble = it.next().value;
			if(currentDouble > edge.value){
				it.previous();
				it.add(edge);
				hasBeenAdded = true;
				break;
			}
		}
		
		if(!hasBeenAdded)
			it.add(edge);
		
		if(sortedList.size() > lengthOfList) sortedList.removeFirst();
		
//		System.out.println("list is now: ");
//		for(EdgeWithIDAndWeight<Integer> edgy: sortedList){
//			System.out.print(edgy.value+" ");
//		}
//		System.out.println();
//		
	}


	private String readInCoocsLine(BufferedReader br, int wantedFirstFilm, String line, double[] simCoocs) {
		if(line == null)
			return null;
		for(int i = 0; i < simCoocs.length; ++i) simCoocs[i] = 0;

		StringTokenizer st = new StringTokenizer(line);
		int firstFilm = Integer.parseInt(st.nextToken());
		
		try {
			//find correct lines in the file
			while(line != null && firstFilm < wantedFirstFilm){
				line = br.readLine();
				st = new StringTokenizer(line);
				firstFilm = Integer.parseInt(st.nextToken());
			}
			
			int secondFilm;
			double value;
			while(line != null && firstFilm == wantedFirstFilm){
				secondFilm = Integer.parseInt(st.nextToken());
				value = Double.parseDouble(st.nextToken());
				simCoocs[secondFilm] = value;
				
				line = br.readLine();
				if(line != null){
					st = new StringTokenizer(line);
					firstFilm = Integer.parseInt(st.nextToken());
				}
			}
		} catch (NumberFormatException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.exit(-1);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.exit(-1);
		}
		
		

		return line;
	}


	private ArrayList<EdgeWithIDAndWeight> computeBestPairsRegardingLeverage(
			int i) {
		// TODO Auto-generated method stub
		return null;
	}


	private ArrayList<EdgeWithIDAndWeight> computeBestPairsRegardingLift(int i) {
		// TODO Auto-generated method stub
		return null;
	}


	private String[] readInMovieTitles(String fileURL) {
		String[] movieTitles = new String[numberOfFilms];
		try {
			BufferedReader br = new BufferedReader(new FileReader(new File(fileURL)));
			String line = br.readLine();
			StringTokenizer st;
			int stringCounter = 0; 
			while(line != null){
				movieTitles[stringCounter++] = line.trim();
				
				line = br.readLine();
			}
			br.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(-1);
		}
		
		
		
		return movieTitles;
	}



	private short[] readInDegrees(String fileURL) {
		short[] filmDegrees = new short[numberOfFilms];
		try {
			BufferedReader br = new BufferedReader(new FileReader(new File(fileURL)));
			String line = br.readLine();
			StringTokenizer st;
			int film, degree;
			while(line != null){
				st = new StringTokenizer(line);
				filmDegrees[Integer.parseInt(st.nextToken())] = Short.parseShort(st.nextToken());
				
				line = br.readLine();
			}
			br.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(-1);
		}
		
		
		return filmDegrees;
	}
	

}
